---
title: 私有成员语法常见问题解答
date: 2018-10-25 22:48:12
tags:
  - 翻译
  - ES
categories:
  - 翻译
  - 前端
  - ES
---

> 译者按：社区一直以来有一个声音，就是使用 `#` 声明私有成员过于丑陋。但是很多质疑的声音过于浅薄，纯属人云亦云。其实 TC39 早就对此类声音做过回应，并且归纳了一篇 FAQ。以下

## `#` 是怎么回事？

`#` 是 `_` 的替代方案。

```js
class A {
  _hidden = 0;
  m() {
    return this._hidden;
  }
}
```

之前大家习惯使用 \_ 创建类的私有成员，但实际上这个成员是暴露的。

```js
class B {
  #hidden = 0;
  m() {
    return this.#hidden;
  }
}
```

现在使用 # 创建类的私有成员，在语言层面上对该成员进行了隐藏。

由于兼容性问题，我们不能仅仅改变 `_` 的工作机制。

> 译者按：如果将私有成员的语义赋予 `_`，之前使用 `_` 声明成员而非私有成员的代码就出问题了。

## 为什么不能通过 `this.x` 访问？

> 译者按：这个问题的意思是，如果类有私有成员 #x（其中 # 是声明私有，x 才是成员名），为什么内部不能通过 this.x 访问该成员，而一定要写成 this.#x？

有 `x` 这个私有成员，不意味着不能有 `x` 这个公有成员，因此访问私有成员不能是一个普通的查找。

这是 JS 的一个问题，因为它缺少静态类型。静态类型语言使用类型声明区分外部公有/内部私有的情况，而不需要标识符。但是动态类型语言没有足够的静态信息区分这些情况。

### 为什么这个提案允许一个类同时存在私有成员 #x 和公有成员 x ？

1. 如果私有成员和公有成员冲突，会破坏其封装性，如下。

2. 私有成员很重要的一点是子类不需要知道它们。我们希望允许子类定义属性 `x`，即使父类有一个同名的私有成员。

其他支持私有成员的语言通常是允许的。如下是完全合法的 Java 代码：

```java
class Base {
  private int x = 0;
}

class Derived extends Base {
  public int x = 0;
}
```

> 译者按：这个问题的回答让我有点糊涂，举的例子中的 Java 也恰恰是不能在一个类中同时声明同名的私有和公有成员。

### 为什么不使用运行时检测，来决定访问的是私有成员还是公有成员？

属性访问的语义已经很复杂了，我们不想仅仅为了这个特性让每次属性访问都更慢。

> 译者按：属性访问的复杂性可以从 [toFastProperties](https://github.com/sindresorhus/to-fast-properties) 和 [toFastProperties 如何使对象的属性更快](https://codeday.me/bug/20170429/11591.html) 窥得一二

它还允许类的方法被非实例的公有字段欺骗，认为其是实例的私有字段。这条[评论](https://github.com/tc39/proposal-private-fields/issues/14#issuecomment-153050837) 是一个例子。

> 译者按：这个例子不够好，无法说服我也无法说服大多数人，感兴趣的可以看下。

### Why not just always have `obj.x` refer to a private field inside of a class which declares a private field `x`?

Class methods often manipulate objects which are not instances of the class. It would be surprising if the code `obj.x` suddenly stopped referring to public field `x` of `obj`, when `obj` is not expected to be an instance of the class, just because that code happened to occur somewhere within a class which declares a private field named `x`, possibly deep within said class.

### Why not give the `this` keyword special semantics?

`this` is already a source of enough confusion in JS; we'd prefer not to make it worse. Also, it's a major refactoring hazard: it would be surprising if `this.x` had different semantics from `const thiz = this; thiz.x`.

This also wouldn't allow accessing fields of objects other than `this`.

### Why not only allow accessing fields of `this`, e.g. by just having a bare `x` refer to the private field `x`?

It is a goal of this proposal to allow accessing private fields of other instances of the same class (see [below](https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#why-does-this-proposal-allow-accessing-private-fields-of-other-instances-of-the-same-class-dont-other-languages-normally-forbid-that)), which requires some syntax. Also, using bare identifiers to refer to properties is not the usual JS way (with the exception of `with`, which is generally considered to have been a mistake).

## Why doesn't `this['#x']` access the private field named `#x`, given that `this.#x` does?

1. This would complicate property access semantics.

2. Dynamic access to private fields is contrary to the notion of 'private'. E.g. this is concerning:

```js
class Dict extends null {
  #data = something_secret;
  add(key, value) {
    this[key] = value;
  }
  get(key) {
    return this[key];
  }
}

new Dict().get("#data"); // returns something_secret
```

### But doesn't giving `this.#x` and `this['#x']` different semantics break an invariant of current syntax?

Not exactly, but it is a concern. `this.#x` has never previously been legal syntax, so from one point of view there can be no invariant regarding it.

On the other hand, it might be surprising that they differ, and this is a downside of the current proposal.

## Why not have access be `this#x`, without the dot?

This would work, but would be an [ASI hazard](https://github.com/tc39/proposal-private-fields/issues/39#issuecomment-237121552) if we later introduced a shorthand syntax of `#x` to mean `this.#x`.

More generally, the committee has mostly come down on the side of `this.#` as more clearly implying field access.

## Why aren't declarations `private x`?

This sort of declaration is what other languages use (notably Java), and implies that access would be done with `this.x`. Assuming that isn't the case (see above), in JavaScript this would silently create or access a public field, rather than throwing an error. This is a major potential source of bugs or invisibly making public fields which were intended to be private.

It also allows a symmetry between declaration and access, just as there is for public fields:

```js
class A {
  pub = 0;
  #priv = 1;
  m() {
    return this.pub + this.#priv;
  }
}
```

## Why does this proposal allow accessing private fields of other instances of the same class? Don't other languages normally forbid that?

It's very useful: see e.g. the `equals` method in the `Point` example in the readme. And in fact, [other languages](https://github.com/tc39/proposal-private-fields/issues/90#issuecomment-307201358) allow it for the same reason; e.g. the following is perfectly legal Java:

```java
class Point {
	private int x = 0;
	private int y = 0;
	public boolean equals(Point p) { return this.x == p.x && this.y == p.y; }
}
```

## Why was the sigil `#` chosen, among all the Unicode code points?

No one came out and said, `#` is the most beautiful, intuitive thing to indicate private state. Instead, it was more of a process of elimination:

- `@` was the initial favorite, but it was taken by decorators. TC39 considered swapping decorators and private state sigils, but the committee decided to defer to the existing usage of transpiler users.
- `_` would cause compatibility issues with existing JavaScript code, which has allowed `_` at the start of an identifier or (public) property name for a long time.
- Other characters which could be used as infix operators, but not prefix operators, are hypothetically possible, such as `%`, `^`, `&`, `?`, given that our syntax is a bit unique--`x.%y` is not valid currently, so there would be no ambiguity. However, the shorthand would lead to ASI issues, e.g., the following would look like using the infix operator:

```js
class Foo {
  %x;
  method() {
    calculate().my().value()
    %x.print()
  }
}
```

Here, the user likely intended to call the `print` method on `this.%x`, but instead, the mod operator will be used!

- Other Unicode code points which are not in ASCII or IDStart could be used, but these might be hard to input for many users; they are not found on common keyboards.

In the end, the only other options are longer sequences of punctuation, which seems suboptimal compared to a single character.

## Why doesn't this proposal allow some mechanism for reflecting on / accessing private fields from outside the class which declares them (e.g. for testing)? Don't other languages normally allow that?

Doing so would violate encapsulation (see [below](https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#why-is-encapsulation-a-goal-of-this-proposal)). That other languages allow it isn't sufficient reason on its own, especially since in some of them (e.g. C++) this is accomplished by modifying memory directly and is not necessarily a goal.

## What do you mean by "encapsulation" / "hard private"?

It means that private fields are _purely_ internal: no JS code outside of a class can detect or affect the existence, name, or value of any private field of instances of said class without directly inspecting the class's source, unless the class chooses to reveal them. (This includes subclasses and superclasses.)

This means that reflection methods like [getOwnPropertySymbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) must not reveal private fields.

This also means that if a class has a private field named `x`, code outside the class which does `obj.x` on an instance `obj` of the class should access the public field `x` just as it would in the absence of the private field. It must _not_ access the private field or throw an error. Note that this doesn't come up as much in languages like Java, which can be type-checked at compile time and do not allow dynamic access to fields by name except via reflection APIs.

## Why is encapsulation a goal of this proposal?

1. Library authors have found that their users will start to depend on any exposed part of their interface, even undocumented parts. They do not generally consider themselves free to break their user's pages and applications just because those users were depending upon some part of the library's interface which the library author did not intend them to depend upon. As a consequence, they would like to have hard private state to be able to hide implementation details in a more complete way.

1. While it's already possible to _model_ true encapsulation using either per-instance closures or WeakMaps (see [below](https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#how-can-you-model-encapsulation-using-weakmaps)), both approaches are unergonomic to use with classes and have memory usage semantics which may be surprising. Furthermore, per-instance closures don't allow instances of the same class to access each other's private fields (see [above](#why-does-this-proposal-allow-accessing-private-fields-of-other-instances-of-the-same-class-dont-other-languages-normally-forbid-that)), and with WeakMaps there's a non-obvious risk of exposing private data. WeakMaps are also likely to be slower than private fields could be.

1. "Hidden" but not encapsulated properties are likewise already possible through the use of Symbols as property names (see [below](https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#how-can-you-provide-hidden-but-not-encapsulated-properties-using-symbols)).

This proposal is currently moving forward with hard-private fields, letting [decorators](https://github.com/tc39/proposal-private-fields/blob/master/DECORATORS.md) or other mechanisms provide classes an opt-in escape hatch. We intend to gather feedback during this process to help determine whether this is the correct semantics.

See [this issue](https://github.com/tc39/proposal-private-fields/issues/33) for more.

### How can you model encapsulation using WeakMaps?

```js
const Person = (function() {
  const privates = new WeakMap();
  let ids = 0;
  return class Person {
    constructor(name) {
      this.name = name;
      privates.set(this, { id: ids++ });
    }
    equals(otherPerson) {
      return privates.get(this).id === privates.get(otherPerson).id;
    }
  };
})();
let alice = new Person("Alice");
let bob = new Person("Bob");
alice.equals(bob); // false
```

There's a potential pitfall with this approach, though. Suppose we want to add a custom callback to construct greetings:

```js
const Person = (function() {
  const privates = new WeakMap();
  let ids = 0;
  return class Person {
    constructor(name, makeGreeting) {
      this.name = name;
      privates.set(this, { id: ids++, makeGreeting });
    }
    equals(otherPerson) {
      return privates.get(this).id === privates.get(otherPerson).id;
    }
    greet(otherPerson) {
      return privates.get(this).makeGreeting(otherPerson.name);
    }
  };
})();
let alice = new Person("Alice", name => `Hello, ${name}!`);
let bob = new Person("Bob", name => `Hi, ${name}.`);
alice.equals(bob); // false
alice.greet(bob); // === 'Hello, Bob!'
```

At first glance this appears fine, but:

```js
let mallory = new Person("Mallory", function(name) {
  this.id = 0;
  return `o/ ${name}`;
});
mallory.greet(bob); // === 'o/ Bob'
mallory.equals(alice); // true. Oops!
```

### How can you provide hidden but not encapsulated properties using Symbols?

```js
const Person = (function() {
  const _id = Symbol("id");
  let ids = 0;
  return class Person {
    constructor(name) {
      this.name = name;
      this[_id] = ids++;
    }
    equals(otherPerson) {
      return this[_id] === otherPerson[_id];
    }
  };
})();
let alice = new Person("Alice");
let bob = new Person("Bob");
alice.equals(bob); // false

alice[Object.getOwnPropertySymbols(alice)[0]]; // == 0, which is alice's id.
```
