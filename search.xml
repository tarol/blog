<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TC39 标准追踪：babel 中的 decorators]]></title>
    <url>%2F2018%2F10%2F25%2FTC39%20%E6%A0%87%E5%87%86%E8%BF%BD%E8%B8%AA%EF%BC%9Ababel%20%E4%B8%AD%E7%9A%84%20decorators%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Babel 7.1.0 终于支持了新的 decorators 提案：你可以通过使用@babel/plugin-proposal-decorators进行体验。 历史的进程&emsp;&emsp;decorators 的第一个方案是由Yehuda Katz在三年前提出的。TypeScript 也在1.5 版本（2015）与 ES6 特性一起发布了 decorators。一些主流的前端框架，比如 angular 和 MobX，也开始用 decorators 加强开发体验：这让 decorators 更加流行，却让社区误以为 decorators 是一个稳定的特性。 &emsp;&emsp;Babel 在5.0 版本实现了 decorators。但是在 Babel 6 移除了它，因为它并不稳定。为此 Logan Smyth 创建了非官方插件 babel-plugin-transform-decorators-legacy，这个插件的实现和 Babel 5 保持一致。直到 Babel 7 alpha 发布，这个插件才重新回到 Babel 的官方库中。该插件仍然使用旧提案的语义，因为新的语义还不够明确。 &emsp;&emsp;从那时候开始，Daniel Ehrenberg 和 Brian Terlson 开始协助 Yehuda Katz 整理新的 decorators 提案，他们几乎重写了这份提案。但即便如此，仍然无法保证面面俱到，迄今为止的实现方式还是不够兼容。 &emsp;&emsp;Babel 7.0.0 为 @babel/plugin-proposal-decorators 引入了一个配置项：legacy，但是当时它只存在 true 这一个合法的值。这个突破性的变化用于日后新旧版本的平滑过渡。 &emsp;&emsp;Babel 7.1.0 提供了对新提案的支持，而且 @babel/plugin-proposal-decorators 默认启用新的实现。 &emsp;&emsp;新提案同时支持对私有成员和私有方法进行装饰，但这些特性在 Babel 中尚未实现，或许很快就会实现了。 新提案有哪些变化？&emsp;&emsp;虽然新提案看上去和旧提案很像，但几个关键的差别导致了两者的不兼容。 语法&emsp;&emsp;旧提案支持任意的左值表达式作为 decorators 的 body（即@后面的内容）。举个例子，这是合法的代码： 1234567class MyClass &#123; @getDecorators().methods[name] foo() &#123;&#125; @decorator [bar]() &#123;&#125;&#125; &emsp;&emsp;这个语法有个问题：[…] 符号同时作为 decorators body 中的属性访问符（即 methods[name] 中的 [name] ）和类方法的计算属性名（即 [bar]() {} 中的 [bar] ）。为了防止语义模糊，新提案中只允许 . 作为属性访问符。如果你想实现诸如@getDecorators().methods[name]的功能，需要借助圆括号： 1234567class MyClass &#123; @(getDecorators().methods[name]) foo() &#123;&#125; @decorator [bar]() &#123;&#125;&#125; 译者按：以上的例子我按个人的理解做了调整。而且据我测试，第一个例子中的第二个 decorator 的写法在旧提案中是错误的。因为 [bar] 会作为 decorators body 的 token 而非 class method 的 name。那么 class method 就不存在 name，会报 unexpected token 的语法错误。 对象 decorators&emsp;&emsp;旧提案除了支持类 decorators、类成员 decorators，还支持对象 decorators： 123456const myObj = &#123; @dec1 foo: 3, @dec2 bar() &#123;&#125;&#125;; &emsp;&emsp;鉴于当前的对象 decorators 语义存在不兼容性，该特性从提案从被移除了。如果你在代码中使用了此特性，请保持关注，因为在后续的 提案 中可能被再次引入。 decorators 参数&emsp;&emsp;第三个关键的改动是 decorators 的参数列表 &emsp;&emsp;在旧提案中，类成员 decorators 接收三个参数，target（类的原型）、key（成员名）、property descriptor（属性描述符）—— 类似于 Object.defineProperty 的参数列表。而类 decorators 仅接收 constructor 这一个参数。 &emsp;&emsp;新提案在这点上要强大的多：成员 decorators 接收一个对象，这个对象包含以下属性，你可以对其进行任意的修改：descriptor(原 descriptor)、key(成员名)、placement(属性的位置，static、prototype、own)、kind(属性的类型，field、method)。 &emsp;&emsp;类 decorators 同样接收一个对象，通过这个对象可以访问到所有的类成员 decorators 的入参，这个特性确保了在创建类之前还可以对类成员做进一步的修改。 译者按：这部分才是最重大的修改，也是不兼容的核心原因。如果要一一列出比较,应该独立成一篇 blog，所以此处不做赘述。 升级方式&emsp;&emsp;由于不兼容，如果项目中采用了新提案，就不能使用旧的 decorators：因为现存的库（MobX， Angular 等）都没有引入新特性，这会导致迁移过程非常慢。鉴于这个问题，我们发布了一个工具包，你可以在你的代码中使用它包装原有的 decorators 作为变通的方案。先运行这个工具包，然后你就可以在 Babel 的 config 中配置新提案了。 &emsp;&emsp;你可以这样更新你的文件 12npm install wrap-legacy-decorators -Dnpx wrap-legacy-decorators src/file-with-decorators.js --decorators-before-export --write &emsp;&emsp;如果你的代码运行在 node 环境，或者你使用 webpack 或者 rollup 打包你的代码，你可以引入外部依赖而不是在每个文件中都注入工具包提供的包装函数。 12npm install decorators-compatnpx wrap-legacy-decorators src/file-with-decorators.js --decorators-before-export --external-helpers --write &emsp;&emsp;更多的信息，你可以参考这个文档。 已知问题&emsp;&emsp;新提案并非是面面俱到的：decorators 是个非常大的特性，要完整的定义它非常的复杂。 Exported Classes 的 decorators 应该放在哪里？ tc39/proposal-decorators#69 &emsp;&emsp;decorators 提案在这个问题上反复摇摆：decorators 应该放在关键字 export 的前面还是后面？ 123456export @decorator class MyClass &#123;&#125;// or@decoratorexport class MyClass &#123;&#125; &emsp;&emsp;这里潜在的一个问题是：export 关键字是类的一部分还是一个“包装器”。第一个例子中，因为 decorators 必须放在声明的开头，所以它应该放在 decorators 后面；第二个例子中，因为 decorators 是声明的一部分，所以它应该放在 decorators 前面。 对于私有成员，decorators 应该采用怎样的安全策略？&emsp;&emsp;decorators 引发了一个重要的安全问题：如果私有成员可以被装饰，那么成员名会泄露。这里需要考虑不同的安全等级： decorators 不能泄露私有成员名，不然恶意代码可以从 decorators 中窃取此信息 私有成员的 decorators 是可信的，类 decorators 是不可信的？ 硬隐私 意味着私有成员只能在类内部访问：那么 decorators 应该访问私有成员名吗？还是只能装饰公有成员？ &emsp;&emsp;这些问题在解决前需要进一步讨论，这也是 Babel 的意义所在。 Babel 充当的角色&emsp;&emsp;随着 Babel 7 的发布，我们开始利用我们在 JS 生态中的地位，通过让开发人员对于不同版本的提案进行体验和给予反馈以帮助提案作者进行决策。 &emsp;&emsp;出于这个原因，更新 @babel/plugin-proposal-decorators 之后，我们引入了新的选项：decoratorsBeforeExport。通过这个选项，你可以尝试切换 export @decorator class C {} 和 @decorator export default class 这两种不同的语法。 &emsp;&emsp;我们还将引入另一个选项来自定义隐私策略。这些选项是必填项，直到 TC39 做出最终的决定，而这个决定将成为默认项。 &emsp;&emsp;如果你是直接使用我们的解析器（@babel/parser，以前的 babylon），你也可以在版本 7.0.0 中使用 decoratorsBeforeExport 这个选项。 123const ast = babylon.parse(code, &#123; plugins: [["decorators", &#123; decoratorsBeforeExport: true &#125;]]&#125;); 使用方式1npm install @babel/plugin-proposal-decorators -D 123456&#123; "plugins": [ "@babel/plugin-proposal-decorators", &#123; "decoratorsBeforeExport": true &#125; ]&#125; &emsp;&emsp;查看 @babel/plugin-proposal-decorators 了解更多的选项。 你的角色&emsp;&emsp;作为一个 JS 开发人员，你可以和我们一起勾勒这个语言的未来。你可以尝试 decorators 提供的各种各样的语义，并给予提案作者一定的反馈。我们需要知道它用于真实项目的情况！你也可以通过阅读 提案仓库 中的讨论和会议纪要了解为何这样设计。 &emsp;&emsp;如果你现在就想体验 decorators，你可以在我们的 线上解释器 通过设置不同的 presets 选项体验它。 翻译自： TC39 Standards Track Decorators in Babel]]></content>
      <categories>
        <category>翻译</category>
        <category>前端</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从web图片裁剪出发：了解H5中的canvas]]></title>
    <url>%2F2016%2F04%2F21%2F%E4%BB%8Eweb%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E5%87%BA%E5%8F%91%EF%BC%9A%E4%BA%86%E8%A7%A3H5%E4%B8%AD%E7%9A%84canvas%2F</url>
    <content type="text"><![CDATA[todo]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>H5</category>
      </categories>
      <tags>
        <tag>文章</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从web图片裁剪出发：了解H5中的Blob]]></title>
    <url>%2F2016%2F04%2F15%2F%E4%BB%8Eweb%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E5%87%BA%E5%8F%91%EF%BC%9A%E4%BA%86%E8%A7%A3H5%E4%B8%AD%E7%9A%84Blob%2F</url>
    <content type="text"><![CDATA[刚开始做前端的时候，有个功能卡住我了，就是裁剪并上传头像。当时两个方案摆在我面前，一个是 flash，我不会。另一个是通过 iframe 上传图片，然后再上传坐标由后端裁剪，而我最终的选择是后者。有人会疑惑，为什么不用 H5 的 Canvas 和 FormData，第一要考虑 ie8 的兼容性，第二那时候眼界没到，这种新东西光是听听都怕。 后来随着 Mobile 项目越做越多，类似的功能开发得也越来越多，Canvas+FormData 成为了标配方案。但做的多了却一直没有静下心来研究，浏览器怎么使用 H5 的方式裁剪并把文件发送出去，回过头看都是知其然不知其所以然。这篇随笔先做个初步的拆解，就是当通过 input 选择一张图片后，这张图片在浏览器里是怎样的一个存在。 文件操作一直是早期浏览器的痛点，全封闭式，不给 JS 操作的空间，而随着 H5 一系列新接口的推出，这个壁垒被打破。对，是一系列接口，以下会涉及到如下概念：Blob、File、FileReader、ArrayBuffer、ArrayBufferView、DataURL 等，其他如 FormData、XMLHttpRequest、Canvas 等暂不深入。 我们先创建一个简单的页面，只有一个 input[type=file]。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="file"&gt;&lt;/body&gt;&lt;/html&gt; 然后我们在 JS 中获取这个元素 1var input = document.querySelector("input[type=file]"); 可以看到这个元素有个属性 files，它的类型是 FileList。这个类不做过多介绍，就是一个类数组，由浏览器通过用户行为往里面添加或删除元素，JS 只有访问其元素的接口，无法对其进行操作。而 files 的元素就是 File 类型，File 是 blob 的子类，比 blob 主要多出一个 name 的属性。 现在我们选取一个文件，这里问题来了，这个元素是文件在浏览器的完整备份，还是一个指向文件系统的引用？答案是后者，我们选定文件，然后修改文件名，再上传文件，浏览器报错了。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name='test'&gt; &lt;input type="file"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;script&gt; var input = document.querySelector('input[type=file]'), form = document.test; form.addEventListener('submit', function(e) &#123; e.preventDefault(); var file = input.files[0], fd = new FormData(), xhr = new XMLHttpRequest(); fd.append('file', file); xhr.open('post', '/upload'); xhr.send(fd); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 chrome 打开 chrome://blob-internals/，可以看到一条这样的记录 可见这仅仅是一条引用。第二个问题来了，如果我们要对图片进行处理，那么只拿到引用是不行的，肯定要在浏览器有一份数据的备份，那么怎么获取这个备份呢？答案就是 FileReader，FileReader 的对象主要有 readAsArrayBuffer、readAsBinaryString、readAsDataURL、readAsText 等方法，它们的入参都是 Blob 对象或是 File 对象，结果对应最终获取的数据类型。这几个方法是异步的，读取过程中会抛出对应的事件，其中读取完毕的事件为 load，所以数据的处理要放在 onload 下。我先给一个简单的 example： 123456789input.addEventListener("change", function() &#123; var file = this.files[0], fr = new FileReader(), blob; fr.onload = function() &#123; blob = new Blob([this.result]); &#125;; fr.readAsArrayBuffer(file);&#125;); 当用户选取图片时，调用 FileReader 的 readAsArrayBuffer 把图片数据读出来，然后生成新的 blob 对象保存在浏览器中。查看 chrome://blob-internals/，可以注意到这一项： 对应的就是刚才的 blob，可以对比 length 和图片本身的大小。上面那个 demo 很突兀，完全没有解释什么是 ArrayBuffer，为什么创建 blob 要传入一个 ArrayBuffer。那么第三个问题来了，什么是 ArrayBuffer、BinaryString、DataURL、Text，它们有什么联系和不同，Blob 类到底是个什么东西？首先，图片是个二进制文件，它的内容也是由 0 和 1 组成的。用户肯定是看不懂 0 和 1 的组合的，能看懂的只有最终展示的图片，而程序员也看不懂 0 和 1，但程序员能看懂另外几种 0 和 1 变换后的组合。它们就是以上的 4 种：ArrayBuffer、BinaryString、DataURL 和 Text。 其中 ArrayBuffer 是最接近二进制数据的表现的，可以理解为它就是二进制数据的存储器，这也是为什么二进制文件的 Blob 需要传入 ArrayBuffer。正因为它的内部是二进制数据，所以我们是不可以直接操作的。这时候就需要一个代理者帮助我们读或写，这个代理者就是 ArrayBufferView。 ArrayBufferView 不是一个类，而是一个类的集合，包括：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array、Float64Array 和 DataView，分别表示以 8 位、16 位、32 位、64 位数字为元素对 ArrayBuffer 内的二进制数据进行展现，它们都有统一的属性 buffer 指向对应的 ArrayBuffer。栗子暂时不举，之后会用到。 ArrayBuffer 简单介绍了，那什么是 BinaryString 呢？是二进制数据直接以 byte 的形式展现的字符串，比如 1100001，用 Uint8 表示就是 97，用 BinaryString 表示就是’a’。对，前者是 charCode，后者是 char，所以 BinaryString 和 Uint8Array 之间是可以自由转换的。 接下来是 DataURL 了，这是一个经过 base64 编码的字符串，它的组成如下：data:[mimeType];base64,[base64(binaryString)] 除了固定的字符串部分，它主要包含两个重要信息即中括号括起的部分，mimeType 和 base64 编码后的 binaryString，从它里面我们可以这样取到这两个信息。 12var binaryString = atob(dataUrl.split(",")[1]), mimeType = dataUrl.split(",")[0].match(/:(.\*?);/)[1]; 最后，Text 是什么呢？在 ftp 上，文本传输和二进制传输的区别是什么，那 Text 类型和 BinaryString 类型的区别就是什么了，也就是 Text 类型是经过一定转换的 BinaryString，对于图片来说，这个类型是用不到的。 好了，现在我们了解了一张图片在浏览器里以数据的形式可以表现为 ArrayBuffer、BinaryString、DataURL，那么第四个问题来了，它们各有实际用途呢？我们从应用场景出发，回到文章开头的问题，图片的裁剪和上传。图片的裁剪我们要倚仗牛逼的 canvas，而 canvas 的 context 有这么一个方法 toDataURL，就是把 canvas 的内容转换为图片数据，而数据的表现形式就是 DataURL！图片的上传我们用的是 FormData，它可以添加 Blob 类型的对象进去，那 Blob 类型除了从 input[type=file]中直接获取，还能靠什么生成呢？自然是 ArrayBuffer！好了，裁剪图片的功能要用到 DataURL，上传图片的功能要用到 ArrayBuffer，那怎么从 DataURL 转换为 ArrayBuffer 呢？我们知道 DataURL 很重要的组成部分就是经过 base64 编码的 BinaryString，那么很显然我们可以从 DataURL 中提取 BinaryString，而 BinaryString 就是 ArrayBuffer 对应的 Uint8Array 的字符形式的表现，所以可以由 BinaryString 生成 ArrayBuffer，那么 DataURL 到 ArrayBuffer 之间的桥就是 BinaryString！ 到现在为止，我们说了很多概念，然而这并没有什么卵用，验证概念的方法不是提出新的概念，而是建立一个 example。以下的 example 就是把图片数据从 input 中取出，然后以 DataURL 的格式进行预览，提交时把预览生成图片上传的整个流程。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name='test'&gt; &lt;input type="file" name='file'&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;img src="" alt=""&gt; &lt;script&gt; var img = document.querySelector('img'), preview; document.test.file.addEventListener('change', function() &#123; var fr = new FileReader(); fr.onload = function() &#123; preview = this.result; img.src = preview; &#125;; fr.readAsDataURL(this.files[0]); &#125;) document.test.addEventListener('submit', function(e) &#123; e.preventDefault(); var binaryString = atob(preview.split(',')[1]), mimeType = preview.split(',')[0].match(/:(.*?);/)[1], length = binaryString.length, u8arr = new Uint8Array(length), blob, fd = new FormData(), xhr = new XMLHttpRequest(); while(length--) &#123; u8arr[length] = binaryString.charCodeAt(length); &#125; blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;); fd.append('file', blob); xhr.open('post', '/upload'); xhr.send(fd); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在图片已经被我们发射出去了，那么图片在协议包里是以怎样的数据形式存在的呢？当然是以二进制的形式，我们抓一下包，发现在 fiddler 里面这个二进制串会转换为字符串，即上面的 binaryString。 既然通过发送的 blob 到最后在数据包里都是以 binaryString 的形式展示，那么是否可以直接使用 xhr.send(binaryString)发送图片呢？貌似是可以的，但我们试一下就会发现问题，服务器获取到的信息不能生成一张图片，说明数据被破坏了。那么数据是谁破坏的呢？这个罪魁祸首就是 send，当 send 的参数是字符串的时候，会对字符串进行 utf8 编码。我们看下相同的图片通过 blob 发送出去和通过 binaryString 直接发送出去的数据会有什么不同。这里我们用 wireshark 抓包，因为 wireshark 会自动对数据块进行分割，可以比较直观的看到图片所对应的数据。PS: 这张图片一张 1px 白色的 png。 前面是正常的图片数据，后面是经过了 utf8 编码的图片数据。我们可以看到数据确实被破坏了，当然在知道元数据是 binaryString 的情况下，这种破坏是可以恢复的，不过不是这里讨论的范畴了，感兴趣的可以跳转阮老师的博客 《字符编码笔记:ASCII，Unicode 和 UTF-8》。 好了，整个图片在浏览器端的拆解到此结束。理解了这些，就走完了写出牛逼的客户端图片裁剪工具的第一步。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>H5</category>
      </categories>
      <tags>
        <tag>文章</tag>
        <tag>H5</tag>
      </tags>
  </entry>
</search>
